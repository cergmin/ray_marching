<!DOCTYPE html>
<html>
<head>
	<meta charset="UTF-8">
	<title>Ray Marching</title>
	<link rel="stylesheet" href="style.css">
	<script src="utils.js"></script>
</head>
<body>
<canvas id="view"></canvas>
<script>
	let MAX_MARCHING_STEPS = 200;
	let MAX_VIEW_DISTANCE = 500;
	let EPSILON = 0.01;

	let camera = {
		cords: {x: 0, y: 10, z: 0},
		direction: {x: 0, y: 0, z: 0}
	};


	let objects = [
		// {
		// 	cords: {x: 5, y: 15, z: 60},
		// 	rotation: {x: 0, y: 0, z: 0},
		// 	r: 8,
		// 	function: function (x, y, z) { // sdf - sphere
		// 		return Math.sqrt(
		// 			Math.pow(x, 2) +
		// 			Math.pow(y, 2) +
		// 			Math.pow(z, 2)
		// 		) - this.r
		// 	}
		// },
		// {
		// 	cords: {x: -10, y: 0 , z: 60},
		// 	rotation: {x: 0, y: 0, z: 0},
		// 	side: 10,
		// 	function: function (x, y, z) { // sdf - cube
		// 		return Math.max(
		// 			Math.abs(x),
		// 			Math.abs(y),
		// 			Math.abs(z),
		//
		// 		) - this.side / 2;
		// 	}
		// },
        {
            cords: {x: 0, y: 10 , z: 60},
            rotation: {x: 0, y: 0, z: 0},
			scale: 20,
            function: function (x, y, z) { // sdf - teapot
                return Math.min(
                    Math.sqrt(x ** 2 + (y - 0.27 * this.scale) ** 2 + z ** 2) - 0.05 * this.scale,
                    Math.sqrt(x ** 2 + 2.5 * (y ** 2) + z ** 2) - 0.4 * this.scale,
                    Math.sqrt((Math.sqrt(x ** 2 + z ** 2) - 0.3 * this.scale) ** 2 + (y - 0.18 * this.scale) ** 2) - 0.02 * this.scale,
                    Math.max(
                        1.15 * x + y - 0.75 * this.scale,
                        -y + 0.09 * this.scale,
                        Math.sqrt(
                            (Math.sqrt((x - 0.55 * this.scale) ** 2 + (y - 0.09 * this.scale) ** 2) - 0.1 * this.scale) ** 2 +
                            (z - 0.1 * this.scale) ** 2
                        ) - 0.04 * this.scale
                    ),
                    Math.max(
                        -(-y + 0.09 * this.scale),
                        Math.sqrt(
                            (Math.sqrt((x - 0.35 * this.scale) ** 2 + (y - 0.09 * this.scale) ** 2) - 0.1 * this.scale) ** 2 +
                            (z - 0.1 * this.scale) ** 2
                        ) - 0.04 * this.scale
                    )
                )
            }
        }
	];

	let view = document.getElementById("view");
	let ctx = view.getContext('2d');

	view.width = document.body.clientWidth;
	view.height = document.body.clientHeight;

	/**
	 * Signed Distance Function
	 *
	 * It gets object and coordinates of ray of light
	 * and returns distance to the object
	 *
	 * obj: object with personal SDF function inside
	 * x, y, z: coordinates of the ray of light
	 */
	function SDF(obj, x, y, z){
		return obj.function(
			obj.cords.x - x,
			obj.cords.y - y,
			obj.cords.z - z
		)
	}

	/**
	 * Returns the shortest SDF all objects
	 *
	 * x, y, z: coordinates of the ray of light
	 */
	function minSDF(x, y, z) {
		let min_dist = SDF(objects[0], x, y, z);

		objects.forEach(function(obj) {
			min_dist = Math.min(min_dist, SDF(obj, x, y, z));
		});

		return min_dist;
	}

	/**
	 * Return the normalized direction to march in from the eye point for a single pixel.
	 *
	 * fieldOfView: vertical field of view in degrees
	 * screenWidth, screenHeight: resolution of the screen
	 * pixelCordX, pixelCordY: the x, y coordinate of the pixel on the screen
	 */
	function rayDirection(fieldOfView, screenWidth, screenHeight, pixelCordX, pixelCordY) {
		let x = pixelCordX - screenWidth / 2;
		let y = pixelCordY - screenHeight / 2;
		let z = screenHeight / Math.tan(Math.radians(fieldOfView) / 2.0);

		return Math.normalize(x, y, z);
	}

	/**
	 * Return the ray length
	 *
	 * ro: ray origin
	 * rd: ray direction
	 */
	function rayMarch(ro, rd){
		let depth = 0;

		for(let i = 0; i < MAX_MARCHING_STEPS; i++){
			let ray_x = ro.x + depth * rd.x;
			let ray_y = ro.y + depth * rd.y;
			let ray_z = ro.z + depth * rd.z;

			let dist = minSDF(ray_x, ray_y, ray_z);

			depth += dist;

			if(dist < EPSILON || depth > MAX_VIEW_DISTANCE){
	            break
			}
		}

		return depth;
	}

    function getNormal(x, y, z){
	    return Math.normalize(
            minSDF(x + EPSILON, y, z) - minSDF(x - EPSILON, y, z),
            minSDF(x, y + EPSILON, z) - minSDF(x, y - EPSILON, z),
            minSDF(x, y, z + EPSILON) - minSDF(x, y, z - EPSILON)
		)
    }

    /**
     * Calculates color using Phong shading
     */
    function getPhongColor(normal, rd){
	    let cos_between_vec = (normal.x * rd.x + normal.y * rd.y + normal.z * rd.z) /
            Math.sqrt((normal.x ** 2 + normal.y ** 2 + normal.z ** 2) * (rd.x ** 2 + rd.y ** 2 + rd.z ** 2));

	    return -cos_between_vec * 255;
	}


    let scale = 1;

	for(let i = 0; i < view.width / scale; i++){
		for(let j = 0; j < view.height / scale; j++){
            let rd = rayDirection(60, view.width / scale, view.height / scale, i, j);
            let rm = rayMarch(camera.cords, rd);

            let normal = getNormal(camera.cords.x + rd.x * rm, camera.cords.y + rd.y * rm, camera.cords.z + rd.z * rm);

            let color = getPhongColor(normal, rd);

            ctx.fillStyle = "rgb(" + color + ", " + color + ", " + color + ")";
            ctx.fillRect(i * scale, j * scale, scale, scale);
		}
	}

    /**
     * Shows information about pixel, when you click on it
     */
    view.onclick = function (e) {
	    let i = e.clientX;
	    let j = e.clientY;

        let rd = rayDirection(60, view.width, view.height, i, j);
        let rm = rayMarch(camera.cords, rd);

        let normal = getNormal(camera.cords.x + rd.x * rm, camera.cords.y + rd.y * rm, camera.cords.z + rd.z * rm);

        let color = (normal.x * rd.x + normal.y * rd.y + normal.z * rd.z) /
            Math.sqrt((normal.x ** 2 + normal.y ** 2 + normal.z ** 2) * (rd.x ** 2 + rd.y ** 2 + rd.z ** 2));

        alert(
            "Color: " + -color +
            "\nNormal X: " + normal.x +
            "\nNormal Y: " + normal.y +
            "\nNormal Z: " + normal.z
		)
    };
</script>
</body>
</html>